#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 20
#define MAX_SUSPEITOS 5

// Estrutura para suspeitos
typedef struct {
    char nome[50];
    char descricao[100];
} Suspeito;

// Estrutura para n√≥ da tabela hash (pista -> suspeito)
typedef struct HashNode {
    char pista[100];
    char suspeito[50];
    struct HashNode* proximo;
} HashNode;

// Estrutura para n√≥ da √°rvore BST de pistas
typedef struct PistaNode {
    char pista[100];
    struct PistaNode* esquerda;
    struct PistaNode* direita;
} PistaNode;

// Estrutura que representa uma sala (n√≥ da √°rvore bin√°ria da mans√£o)
typedef struct Sala {
    char nome[50];
    struct Sala* esquerda;
    struct Sala* direita;
} Sala;

// Tabela hash global para associa√ß√µes pista-suspeito
HashNode* tabelaHash[HASH_SIZE];

// Lista de suspeitos dispon√≠veis
Suspeito suspeitos[MAX_SUSPEITOS] = {
    {"Dr. Marcus", "M√©dico da fam√≠lia, tem acesso a venenos"},
    {"Sra. Helena", "Governanta, conhece todos os segredos da casa"},
    {"Prof. Viktor", "Professor de qu√≠mica, especialista em subst√¢ncias"},
    {"James Butler", "Mordomo, tem acesso a todas as √°reas"},
    {"Lady Catherine", "Herdeira, tem motivos financeiros"}
};

/**
 * Fun√ß√£o: funcaoHash
 * Descri√ß√£o: Calcula o √≠ndice hash para uma string usando algoritmo djb2
 * Par√¢metros: str - string para calcular o hash
 * Retorno: √≠ndice da tabela hash
 */
unsigned int funcaoHash(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash % HASH_SIZE;
}

/**
 * Fun√ß√£o: criarSala
 * Descri√ß√£o: Cria uma nova sala de forma din√¢mica
 * Par√¢metros: nome - string com o nome da sala
 * Retorno: ponteiro para a sala criada
 */
Sala* criarSala(char* nome) {
    Sala* novaSala = (Sala*)malloc(sizeof(Sala));
    
    if (novaSala == NULL) {
        printf("‚ùå Erro: N√£o foi poss√≠vel alocar mem√≥ria para a sala.\n");
        exit(1);
    }
    
    strcpy(novaSala->nome, nome);
    novaSala->esquerda = NULL;
    novaSala->direita = NULL;
    
    return novaSala;
}

/**
 * Fun√ß√£o: criarPistaNode
 * Descri√ß√£o: Cria um novo n√≥ para a √°rvore BST de pistas
 * Par√¢metros: pista - string com o conte√∫do da pista
 * Retorno: ponteiro para o n√≥ criado
 */
PistaNode* criarPistaNode(char* pista) {
    PistaNode* novoNode = (PistaNode*)malloc(sizeof(PistaNode));
    
    if (novoNode == NULL) {
        printf("‚ùå Erro: N√£o foi poss√≠vel alocar mem√≥ria para a pista.\n");
        exit(1);
    }
    
    strcpy(novoNode->pista, pista);
    novoNode->esquerda = NULL;
    novoNode->direita = NULL;
    
    return novoNode;
}

/**
 * Fun√ß√£o: inserirPista
 * Descri√ß√£o: Insere uma nova pista na √°rvore BST mantendo ordem alfab√©tica
 * Par√¢metros: raiz - ponteiro para a raiz da √°rvore BST
 *             pista - string com a pista a ser inserida
 * Retorno: ponteiro para a raiz atualizada
 */
PistaNode* inserirPista(PistaNode* raiz, char* pista) {
    if (raiz == NULL) {
        return criarPistaNode(pista);
    }
    
    int comparacao = strcmp(pista, raiz->pista);
    
    if (comparacao < 0) {
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    } else if (comparacao > 0) {
        raiz->direita = inserirPista(raiz->direita, pista);
    }
    // Se igual, n√£o insere duplicata
    
    return raiz;
}

/**
 * Fun√ß√£o: inserirNaHash
 * Descri√ß√£o: Insere associa√ß√£o pista/suspeito na tabela hash
 * Par√¢metros: pista - string com a pista
 *             suspeito - string com o nome do suspeito
 * Retorno: void
 */
void inserirNaHash(char* pista, char* suspeito) {
    unsigned int indice = funcaoHash(pista);
    
    HashNode* novoNode = (HashNode*)malloc(sizeof(HashNode));
    if (novoNode == NULL) {
        printf("‚ùå Erro: N√£o foi poss√≠vel alocar mem√≥ria para hash.\n");
        exit(1);
    }
    
    strcpy(novoNode->pista, pista);
    strcpy(novoNode->suspeito, suspeito);
    novoNode->proximo = tabelaHash[indice];
    tabelaHash[indice] = novoNode;
}

/**
 * Fun√ß√£o: encontrarSuspeito
 * Descri√ß√£o: Consulta o suspeito correspondente a uma pista na tabela hash
 * Par√¢metros: pista - string com a pista para buscar
 * Retorno: ponteiro para o nome do suspeito ou NULL se n√£o encontrado
 */
char* encontrarSuspeito(char* pista) {
    unsigned int indice = funcaoHash(pista);
    HashNode* atual = tabelaHash[indice];
    
    while (atual != NULL) {
        if (strcmp(atual->pista, pista) == 0) {
            return atual->suspeito;
        }
        atual = atual->proximo;
    }
    
    return NULL; // Pista n√£o encontrada
}

/**
 * Fun√ß√£o: obterPistaPorSala
 * Descri√ß√£o: Retorna a pista espec√≠fica associada a uma sala
 * Par√¢metros: nomeSala - nome da sala para obter a pista
 * Retorno: ponteiro para a string da pista ou NULL se n√£o houver
 */
char* obterPistaPorSala(char* nomeSala) {
    // Defini√ß√£o est√°tica das pistas por sala
    if (strcmp(nomeSala, "Hall de Entrada") == 0) {
        return "Pegadas molhadas de sapatos caros";
    } else if (strcmp(nomeSala, "Biblioteca") == 0) {
        return "Livro de toxicologia com p√°ginas marcadas";
    } else if (strcmp(nomeSala, "Laborat√≥rio") == 0) {
        return "Frasco de cianeto parcialmente vazio";
    } else if (strcmp(nomeSala, "Escrit√≥rio") == 0) {
        return "Testamento alterado recentemente";
    } else if (strcmp(nomeSala, "Cozinha") == 0) {
        return "Restos de plantas venenosas no liquidificador";
    } else if (strcmp(nomeSala, "Quarto Principal") == 0) {
        return "Carta de chantagem escondida na gaveta";
    } else if (strcmp(nomeSala, "Jardim") == 0) {
        return "Ferramentas de jardinagem com traces suspeitos";
    } else if (strcmp(nomeSala, "Adega") == 0) {
        return "Garrafa de vinho adulterada";
    } else if (strcmp(nomeSala, "Cofre Secreto") == 0) {
        return "Documentos comprometedores sobre heran√ßas";
    }
    
    return NULL; // Sala sem pista
}

/**
 * Fun√ß√£o: exibirPistas
 * Descri√ß√£o: Exibe todas as pistas coletadas em ordem alfab√©tica
 * Par√¢metros: raiz - ponteiro para a raiz da √°rvore BST
 *             contador - ponteiro para contador de pistas
 * Retorno: void
 */
void exibirPistas(PistaNode* raiz, int* contador) {
    if (raiz != NULL) {
        exibirPistas(raiz->esquerda, contador);
        (*contador)++;
        char* suspeito = encontrarSuspeito(raiz->pista);
        printf("  %d. %s\n", *contador, raiz->pista);
        printf("     üë§ Aponta para: %s\n", suspeito ? suspeito : "Suspeito desconhecido");
        exibirPistas(raiz->direita, contador);
    }
}

/**
 * Fun√ß√£o: contarPistasPorSuspeito
 * Descri√ß√£o: Conta quantas pistas apontam para um suspeito espec√≠fico
 * Par√¢metros: raiz - ponteiro para a raiz da √°rvore BST
 *             suspeitoAlvo - nome do suspeito para contar
 * Retorno: n√∫mero de pistas que apontam para o suspeito
 */
int contarPistasPorSuspeito(PistaNode* raiz, char* suspeitoAlvo) {
    if (raiz == NULL) {
        return 0;
    }
    
    int count = 0;
    char* suspeito = encontrarSuspeito(raiz->pista);
    
    if (suspeito && strcmp(suspeito, suspeitoAlvo) == 0) {
        count = 1;
    }
    
    return count + 
           contarPistasPorSuspeito(raiz->esquerda, suspeitoAlvo) +
           contarPistasPorSuspeito(raiz->direita, suspeitoAlvo);
}

/**
 * Fun√ß√£o: explorarSalas
 * Descri√ß√£o: Permite navega√ß√£o pela mans√£o ativando o sistema de pistas
 * Par√¢metros: salaAtual - ponteiro para a sala onde o jogador est√°
 *             pistasColetadas - ponteiro para ponteiro da √°rvore BST de pistas
 * Retorno: void
 */
void explorarSalas(Sala* salaAtual, PistaNode** pistasColetadas) {
    char escolha;
    
    while (salaAtual != NULL) {
        printf("\nüè∞ === DETECTIVE QUEST - INVESTIGA√á√ÉO MESTRE ===\n");
        printf("üìç Voc√™ est√° na: %s\n", salaAtual->nome);
        
        // Verifica se h√° pista na sala atual
        char* pista = obterPistaPorSala(salaAtual->nome);
        if (pista != NULL) {
            printf("üîç PISTA DESCOBERTA: %s\n", pista);
            *pistasColetadas = inserirPista(*pistasColetadas, pista);
            
            char* suspeito = encontrarSuspeito(pista);
            if (suspeito) {
                printf("üéØ Esta pista aponta para: %s\n", suspeito);
            }
            printf("‚úÖ Pista adicionada ao seu dossi√™!\n");
        } else {
            printf("‚ùå Nenhuma pista encontrada nesta sala.\n");
        }
        
        // Verifica se √© uma sala sem sa√≠das
        if (salaAtual->esquerda == NULL && salaAtual->direita == NULL) {
            printf("\nüö™ Esta sala n√£o possui mais caminhos!\n");
            printf("üí° Voc√™ pode sair para come√ßar a fase de julgamento.\n");
        }
        
        // Mostra as op√ß√µes dispon√≠veis
        printf("\nüìã Op√ß√µes dispon√≠veis:\n");
        if (salaAtual->esquerda != NULL) {
            printf("  (e) - Ir para esquerda: %s\n", salaAtual->esquerda->nome);
        }
        if (salaAtual->direita != NULL) {
            printf("  (d) - Ir para direita: %s\n", salaAtual->direita->nome);
        }
        printf("  (s) - Sair e iniciar julgamento\n");
        
        printf("\n‚û§ Escolha uma op√ß√£o: ");
        scanf(" %c", &escolha);
        
        // Processa a escolha do jogador
        switch (escolha) {
            case 'e':
            case 'E':
                if (salaAtual->esquerda != NULL) {
                    salaAtual = salaAtual->esquerda;
                } else {
                    printf("‚ö†Ô∏è  N√£o h√° caminho √† esquerda!\n");
                }
                break;
                
            case 'd':
            case 'D':
                if (salaAtual->direita != NULL) {
                    salaAtual = salaAtual->direita;
                } else {
                    printf("‚ö†Ô∏è  N√£o h√° caminho √† direita!\n");
                }
                break;
                
            case 's':
            case 'S':
                printf("\n‚öñÔ∏è  Iniciando fase de julgamento...\n");
                return;
                
            default:
                printf("‚ùå Op√ß√£o inv√°lida! Tente novamente.\n");
                break;
        }
    }
}

/**
 * Fun√ß√£o: verificarSuspeitoFinal
 * Descri√ß√£o: Conduz √† fase de julgamento final verificando a acusa√ß√£o
 * Par√¢metros: pistasColetadas - ponteiro para a raiz da √°rvore BST de pistas
 * Retorno: void
 */
void verificarSuspeitoFinal(PistaNode* pistasColetadas) {
    printf("\n" "==========================================\n");
    printf("‚öñÔ∏è  FASE DE JULGAMENTO - DETECTIVE QUEST\n");
    printf("==========================================\n");
    
    if (pistasColetadas == NULL) {
        printf("‚ùå Voc√™ n√£o coletou nenhuma pista!\n");
        printf("üí° Sem evid√™ncias, √© imposs√≠vel fazer uma acusa√ß√£o.\n");
        printf("üîÑ Tente explorar mais a mans√£o na pr√≥xima vez.\n");
        return;
    }
    
    printf("üìã DOSSI√ä COMPLETO - Pistas coletadas:\n\n");
    int contador = 0;
    exibirPistas(pistasColetadas, &contador);
    printf("\nüìä Total de pistas coletadas: %d\n", contador);
    
    printf("\nüë• SUSPEITOS DISPON√çVEIS:\n");
    for (int i = 0; i < MAX_SUSPEITOS; i++) {
        printf("  %d. %s - %s\n", i + 1, suspeitos[i].nome, suspeitos[i].descricao);
    }
    
    printf("\nüéØ Baseado nas evid√™ncias, quem voc√™ acusa?\n");
    printf("Digite o n√∫mero do suspeito (1-%d): ", MAX_SUSPEITOS);
    
    int escolha;
    scanf("%d", &escolha);
    
    if (escolha < 1 || escolha > MAX_SUSPEITOS) {
        printf("‚ùå N√∫mero inv√°lido! Julgamento cancelado.\n");
        return;
    }
    
    char* suspeitoAcusado = suspeitos[escolha - 1].nome;
    printf("\n‚öñÔ∏è  ACUSA√á√ÉO FORMAL: %s\n", suspeitoAcusado);
    
    // Conta pistas que apontam para o suspeito acusado
    int pistasQueApontam = contarPistasPorSuspeito(pistasColetadas, suspeitoAcusado);
    
    printf("\nüìà AN√ÅLISE DAS EVID√äNCIAS:\n");
    printf("   Pistas que apontam para %s: %d\n", suspeitoAcusado, pistasQueApontam);
    printf("   Evid√™ncias necess√°rias para condena√ß√£o: 2\n");
    
    printf("\n" "==========================================\n");
    
    if (pistasQueApontam >= 2) {
        printf("‚úÖ VEREDICTO: CULPADO!\n");
        printf("üéâ Parab√©ns, Detective! Voc√™ reuniu evid√™ncias suficientes!\n");
        printf("‚öñÔ∏è  %s foi considerado culpado com base em %d pistas s√≥lidas.\n", 
               suspeitoAcusado, pistasQueApontam);
        printf("üèÜ Caso resolvido com sucesso!\n");
    } else {
        printf("‚ùå VEREDICTO: EVID√äNCIAS INSUFICIENTES\n");
        printf("üòû Infelizmente, voc√™ n√£o reuniu evid√™ncias suficientes.\n");
        printf("üí° S√£o necess√°rias pelo menos 2 pistas para uma condena√ß√£o.\n");
        printf("üîÑ O suspeito foi liberado. Tente novamente!\n");
    }
    
    printf("==========================================\n");
}

/**
 * Fun√ß√£o: inicializarTabelaHash
 * Descri√ß√£o: Inicializa a tabela hash e preenche com associa√ß√µes pista-suspeito
 * Retorno: void
 */
void inicializarTabelaHash() {
    // Inicializa todos os ponteiros como NULL
    for (int i = 0; i < HASH_SIZE; i++) {
        tabelaHash[i] = NULL;
    }
    
    // Preenche associa√ß√µes pista -> suspeito
    inserirNaHash("Pegadas molhadas de sapatos caros", "Dr. Marcus");
    inserirNaHash("Livro de toxicologia com p√°ginas marcadas", "Prof. Viktor");
    inserirNaHash("Frasco de cianeto parcialmente vazio", "Prof. Viktor");
    inserirNaHash("Testamento alterado recentemente", "Lady Catherine");
    inserirNaHash("Restos de plantas venenosas no liquidificador", "Sra. Helena");
    inserirNaHash("Carta de chantagem escondida na gaveta", "James Butler");
    inserirNaHash("Ferramentas de jardinagem com traces suspeitos", "Sra. Helena");
    inserirNaHash("Garrafa de vinho adulterada", "Dr. Marcus");
    inserirNaHash("Documentos comprometedores sobre heran√ßas", "Lady Catherine");
}

/**
 * Fun√ß√£o: liberarMemoriaSalas
 * Descri√ß√£o: Libera a mem√≥ria alocada para toda a √°rvore de salas
 * Par√¢metros: raiz - ponteiro para a raiz da √°rvore de salas
 * Retorno: void
 */
void liberarMemoriaSalas(Sala* raiz) {
    if (raiz != NULL) {
        liberarMemoriaSalas(raiz->esquerda);
        liberarMemoriaSalas(raiz->direita);
        free(raiz);
    }
}

/**
 * Fun√ß√£o: liberarMemoriaPistas
 * Descri√ß√£o: Libera a mem√≥ria alocada para toda a √°rvore BST de pistas
 * Par√¢metros: raiz - ponteiro para a raiz da √°rvore BST
 * Retorno: void
 */
void liberarMemoriaPistas(PistaNode* raiz) {
    if (raiz != NULL) {
        liberarMemoriaPistas(raiz->esquerda);
        liberarMemoriaPistas(raiz->direita);
        free(raiz);
    }
}

/**
 * Fun√ß√£o: liberarMemoriaHash
 * Descri√ß√£o: Libera a mem√≥ria alocada para a tabela hash
 * Retorno: void
 */
void liberarMemoriaHash() {
    for (int i = 0; i < HASH_SIZE; i++) {
        HashNode* atual = tabelaHash[i];
        while (atual != NULL) {
            HashNode* temp = atual;
            atual = atual->proximo;
            free(temp);
        }
    }
}

/**
 * Fun√ß√£o: main
 * Descri√ß√£o: Programa principal que monta a mans√£o e coordena toda a investiga√ß√£o
 * Retorno: 0 se executado com sucesso
 */
int main() {
    printf("üéÆ === DETECTIVE QUEST - N√çVEL MESTRE ===\n");
    printf("üïµÔ∏è  Bem-vindo √† investiga√ß√£o mais complexa!\n");
    printf("üéØ Objetivo: Colete pistas, analise suspeitos e resolva o caso!\n");
    printf("‚öñÔ∏è  Voc√™ precisar√° de pelo menos 2 pistas para condenar um suspeito.\n\n");
    
    // Inicializa as estruturas de dados
    inicializarTabelaHash();
    PistaNode* pistasColetadas = NULL;
    
    // Cria√ß√£o do mapa da mans√£o - estrutura mais complexa
    Sala* hall = criarSala("Hall de Entrada");
    
    // Segundo n√≠vel
    Sala* biblioteca = criarSala("Biblioteca");
    Sala* cozinha = criarSala("Cozinha");
    
    // Terceiro n√≠vel - lado esquerdo
    Sala* laboratorio = criarSala("Laborat√≥rio");
    Sala* escritorio = criarSala("Escrit√≥rio");
    
    // Terceiro n√≠vel - lado direito
    Sala* quartoMain = criarSala("Quarto Principal");
    Sala* jardim = criarSala("Jardim");
    
    // Quarto n√≠vel - salas finais
    Sala* adega = criarSala("Adega");
    Sala* cofreSecreto = criarSala("Cofre Secreto");
    
    // Montagem da estrutura da √°rvore
    hall->esquerda = biblioteca;
    hall->direita = cozinha;
    
    biblioteca->esquerda = laboratorio;
    biblioteca->direita = escritorio;
    
    cozinha->esquerda = quartoMain;
    cozinha->direita = jardim;
    
    escritorio->direita = adega;
    jardim->direita = cofreSecreto;
    
    printf("üè∞ Mans√£o do mist√©rio criada com sucesso!\n");
    printf("üó∫Ô∏è  Estrutura da mans√£o:\n");
    printf("                    Hall de Entrada\n");
    printf("                   /              \\\n");
    printf("              Biblioteca        Cozinha\n");
    printf("              /       \\        /      \\\n");
    printf("       Laborat√≥rio  Escrit√≥rio Quarto  Jardim\n");
    printf("                        \\      Principal   \\\n");
    printf("                       Adega            Cofre Secreto\n");
    
    printf("\nüîç A mans√£o est√° cheia de pistas. Explore com cuidado!\n");
    printf("üéØ Lembre-se: voc√™ precisa de evid√™ncias s√≥lidas para o julgamento.\n");
    
    // Inicia a explora√ß√£o
    explorarSalas(hall, &pistasColetadas);
    
    // Fase de julgamento
    verificarSuspeitoFinal(pistasColetadas);
    
    // Libera toda a mem√≥ria alocada
    liberarMemoriaSalas(hall);
    liberarMemoriaPistas(pistasColetadas);
    liberarMemoriaHash();
    
    printf("\nüéÆ Obrigado por jogar Detective Quest - N√≠vel Mestre!\n");
    printf("üéì Voc√™ dominou: √Årvores Bin√°rias, BST e Tabelas Hash!\n");
    
    return 0;
}
